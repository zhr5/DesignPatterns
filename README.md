# DesignPatterns
常用设计模式实战

## 原则

- 单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】: 一个类负责一项职责。这个原则鼓励将功能分解成小的、独立的单元。
- 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。里氏替换原则是实现开闭原则的重要方式之一。在软件中将一个基类对象替换成它的子类对象，程序不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。例如，有一个图形绘制程序，基类是 “图形”，有子类 “圆形”“矩形”“三角形” 等。在程序中任何使用 “图形” 对象的地方，都可以用 “圆形”“矩形” 等子类对象来替换，而不影响程序的正确性。这样可以方便地扩展程序的功能，当需要增加新的图形类型时，只需要创建新的子类，而不需要修改已有的代码。
- 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。依赖倒置原则的核心是面向接口编程。传统的编程方式中，高层模块往往直接依赖于低层模块，这样会导致高层模块和低层模块之间的紧密耦合，一旦低层模块发生变化，高层模块也需要随之修改。而采用依赖倒置原则，高层模块和低层模块都依赖于抽象接口，当低层模块发生变化时，只需要修改实现接口的具体类，而不会影响到高层模块。例如，在一个电商系统中，订单处理模块是高层模块，支付模块是低层模块。如果订单处理模块直接依赖于具体的支付方式（如支付宝支付、微信支付等），那么当增加一种新的支付方式时，订单处理模块就需要进行修改。而如果订单处理模块依赖于一个支付接口，各种支付方式实现这个接口，那么当增加新的支付方式时，只需要新增一个实现支付接口的类，而订单处理模块无需修改。
- 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。
- 迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。迪米特法则的核心思想是降低对象之间的耦合度，提高模块的相对独立性。一个对象应该尽量少地与其他对象发生相互作用，只与直接的朋友通信。例如，在一个学校管理系统中，教师对象需要知道学生对象的成绩信息。如果教师对象直接访问学生对象的成绩属性，就违反了迪米特法则。正确的做法是，通过学生对象提供的方法来获取成绩信息，这样可以降低教师对象和学生对象之间的耦合度。如果学生对象的成绩存储方式发生变化，只需要修改学生对象的相关方法，而不会影响到教师对象。
- 开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。开闭原则是面向对象设计中最基础的设计原则。当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是修改已有的代码。这样可以保证软件具有良好的可维护性和可扩展性。例如，有一个图形绘制程序，最初只支持绘制圆形和矩形。如果要增加绘制三角形的功能，按照开闭原则，不应该修改已有的绘制圆形和矩形的代码，而是创建一个新的三角形类，并在程序中扩展支持绘制三角形。这样，当以后需要增加更多的图形类型时，只需要创建新的图形类，而不会影响到已有的代码。
- 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。

## 模板方法
定义算法框架，并将一些步骤的实现延迟到子类。

通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

类图

![img_1.png](img_1.png)

1.收银台

![img.png](img.png)

2.支付回调

## 工厂模式+责任链模式

1.开户

工厂模式＋责任链模式

2.对账获取解析器

使用工厂模式（Factory Pattern）的一种变体：
通过支付方式（interfaceCode）确定具体使用哪个解析器。
getService方法扮演了工厂的角色，根据名称创建并返回具体的解析器实例。

